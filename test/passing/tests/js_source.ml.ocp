d36 2
a37 2
  let x = 1 in
  x]
d57 3
a59 3
       [%foo:
         val x : t
         val y : t])
d86 1
a86 1
     ()) [@foo]];
d117 1
a117 1
             ((lazy x) [@foo])] -> ()
d124 11
a134 11
  let[@foo] x = 3 in
  object
    inherit x [@@foo]
    val x = 3 [@@foo]
    val virtual x : t [@@foo]
    val! mutable x = 3 [@@foo]
    method x = 3 [@@foo]
    method virtual x : t [@@foo]
    method! private x = 3 [@@foo]
    initializer x [@@foo]
  end [@foo]
d158 1
a158 1
                                                                                     [@foo]
d386 1
a386 1
  fun f i1 ->
d545 1
a545 1
      method m = 3
d655 1
a655 1
    type t = string
d657 4
a660 4
    let label = "string"
    let read s = s
    let write s = s
  end)
d894 1
a894 1
    This has used the equation t = bool, not visible in the return type **)
d911 1
a911 1
   t = int *)
d917 2
a918 2
     let _ = id true in
     id)
d958 1
a958 1
  fun ty x ->
d972 1
a972 1
  fun ty v ->
d1013 1
a1013 1
  fun ty x ->
d1021 1
a1021 1
  (* t = ('a, 'b) for some 'a and 'b *)
d1055 1
a1055 1
  fun ty v ->
d1066 2
a1067 2
         if label <> lab then raise VariantMismatch;
         set builder (devariantize field_type v))
d1152 1
a1152 1
  fun s1 s2 ->
d1167 1
a1167 1
  fun sel cases ->
d1196 1
a1196 1
  fun e ty v ->
d1217 1
a1217 1
            | Tdyn (ty, arg) -> variantize e ty arg)
d1222 1
a1222 1
  fun e ty v ->
d1277 3
a1279 3
      | Thd, v -> `A v
      | Ttl Thd, v -> `B v
      | Ttl (Ttl Thd), Noarg -> `C
d1303 1
a1303 1
  fun t ->
d1309 2
a1310 2
             | `Nil -> "Nil", None
             | `Cons p -> "Cons", Some (Tdyn (tcons, p)))
d1315 2
a1316 2
              | Thd, Noarg -> `Nil
              | Ttl Thd, v -> `Cons v)
d1345 3
a1347 3
        | `A n -> "A", Some (Tdyn (Int, n))
        | `B s -> "B", Some (Tdyn (String, s))
        | `C -> "C", None)
d1357 1
a1357 1
  fun t ->
d1362 2
a1363 2
           | `Nil -> "Nil", None
           | `Cons p -> "Cons", Some (Tdyn (targ, p)))
d1400 19
a1418 19
      method proj =
        function
        | `A n -> "A", Some (Tdyn (Int, n))
        | `B s -> "B", Some (Tdyn (String, s))
        | `C -> "C", None

      method cases =
        [ "A", TCarg (Thd, Int)
        ; "B", TCarg (Ttl Thd, String)
        ; "C", TCnoarg (Ttl (Ttl Thd))
        ]

      method inj
        : type c.  (int -> string -> noarg -> unit, c) ty_sel * c
          -> [ `A of int | `B of string | `C ] =
        function
        | Thd, v -> `A v
        | Ttl Thd, v -> `B v
        | Ttl (Ttl Thd), Noarg -> `C
d1428 1
a1428 1
  fun t ->
d1433 11
a1443 11
         method proj =
           function
           | `Nil -> "Nil", None
           | `Cons p -> "Cons", Some (Tdyn (tcons, p))

         method cases = [ "Nil", TCnoarg Thd; "Cons", TCarg (Ttl Thd, tcons) ]

         method inj : type c. (noarg -> a * a vlist -> unit, c) ty_sel * c -> a vlist =
           function
           | Thd, Noarg -> `Nil
           | Ttl Thd, v -> `Cons v
d1448 8
a1455 8
   type (_,_) ty_assoc =
   | Anil : (unit,'e) ty_assoc
   | Acons : string * ('a,'e) ty * ('b,'e) ty_assoc -> ('a -> 'b, 'e) ty_assoc

   and (_,_) ty_pvar =
   | Pnil : ('a,'e) ty_pvar
   | Pconst : 't * ('b,'e) ty_pvar -> ('t -> 'b, 'e) ty_pvar
   | Parg : 't * ('a,'e) ty * ('b,'e) ty_pvar -> ('t * 'a -> 'b, 'e) ty_pvar
d1460 2
a1461 2
   Generic Programming in Omega, by Tim Sheard and Nathan Linger
   http://web.cecs.pdx.edu/~sheard/
d1503 1
a1503 1
  fun xs ys ->
d1547 1
a1547 1
  fun eq n t ->
d1556 1
a1556 1
  fun p t ->
d1585 1
a1585 1
  fun p ->
d1598 1
a1598 1
  fun a b ->
d1611 1
a1611 1
  fun p1 p2 ->
d1627 1
a1627 1
  fun p1 p2 p3 p4 ->
d1649 8
a1656 8
   let rec diff : type a b. (a,b) le -> a nat -> b nat -> (a,b) diff =
   fun le a b ->
   match a, b, le with
   | NZ, m, _ -> Diff (m, PlusZ m)
   | NS x, NZ, _ -> assert false
   | NS x, NS y, q ->
   match diff (smaller q) x y with Diff (m, p) -> Diff (m, PlusS p)
   ;;
d1660 1
a1660 1
  fun le a b ->
d1669 1
a1669 1
  fun le a b ->
d1680 1
a1680 1
  fun le b ->
d1696 1
a1696 1
  fun f s ->
d1721 1
a1721 1
  fun x t ->
d1730 1
a1730 1
  fun tL y tR ->
d1745 1
a1745 1
  fun tL u tR ->
d1758 1
a1758 1
  fun x t ->
d1808 1
a1808 1
  fun y t ->
d1895 1
a1895 1
  fun ct t ->
d1921 1
a1921 1
  fun t ct ->
d1933 1
a1933 1
  fun e t ct ->
d1977 1
a1977 1
  fun ra rb ->
d2001 9
a2009 9
  fun x r -> function
    | [] -> raise Not_found
    | Assoc (x', r', v) :: env ->
      if x = x'
      then (
        match rep_equal r r' with
        | None -> failwith ("Wrong type for " ^ x)
        | Some Eq -> v)
      else assoc x r env
d2022 8
a2029 8
  fun env -> function
    | Var (x, r) -> assoc x r env
    | Abs (x, r, e) -> fun v -> eval_term (Assoc (x, r, v) :: env) e
    | Const x -> x
    | Add -> fun (x, y) -> x + y
    | LT -> fun (x, y) -> x < y
    | Ap (f, x) -> eval_term env f (eval_term env x)
    | Pair (x, y) -> eval_term env x, eval_term env y
d2063 1
a2063 1
  fun env m ->
d2096 1
a2096 1
  fun a b ->
d2125 1
a2125 1
  fun name ctx ->
d2138 1
a2138 1
  fun n ctx t ->
d2220 1
a2220 1
  fun t s ->
d2244 1
a2244 1
  fun v1 v2 ->
d2281 1
a2281 1
  fun ta tb ->
d2339 9
a2347 9
    fun allow_link ast ->
      match allow_link, ast with
      | Maylink, Ast_Text txt -> Text txt
      | Nonlink, Ast_Text txt -> Text txt
      | x, Ast_Bold xs -> Bold (List.map (process x) xs)
      | Maylink, Ast_Link lnk -> Link lnk
      | Nonlink, Ast_Link _ -> assert false
      | Maylink, Ast_Mref (lnk, xs) -> Mref (lnk, List.map (process Nonlink) xs)
      | Nonlink, Ast_Mref _ -> assert false
d2357 8
a2364 8
    fun allow_link ast ->
      match allow_link, ast with
      | Kind _, Ast_Text txt -> Text txt
      | x, Ast_Bold xs -> Bold (List.map (process x) xs)
      | Kind Maylink, Ast_Link lnk -> Link lnk
      | Kind Nonlink, Ast_Link _ -> assert false
      | Kind Maylink, Ast_Mref (lnk, xs) -> Mref (lnk, List.map (process (Kind Nonlink)) xs)
      | Kind Nonlink, Ast_Mref _ -> assert false
d2370 2
a2371 2
    type two
  end) =
d2394 1
a2394 1
  fun x ->
d2429 1
a2429 1
  (* constraint 'a = [< `TagA of int | `TagB] *)
d2447 1
a2447 1
  fun w ->
d2456 2
a2457 2
    type 'a t
  end) =
d2464 1
a2464 1
    fun (l : int S.t ab) (r : float S.t ab) ->
d2467 1
a2467 1
  ;;
d2471 2
a2472 2
    type 'a t
  end) =
d2482 1
a2482 1
    fun l r ->
d2485 1
a2485 1
  ;;
d2574 3
a2576 3
    type 'a t = T of 'a
    type 'a s = T of 'a
  end) =
d2613 4
a2616 4
    module type T
  end) (B : sig
          module type T
        end) =
d2641 2
a2642 2
    | Local -> fun _ -> raise Exit
    | Global -> fun _ -> raise Exit
d2647 2
a2648 2
    | Local -> fun _ -> raise Exit
    | Global -> fun _ -> raise Exit
d2654 2
a2655 2
    | Local -> fun _ -> raise Exit
    | Global -> fun _ -> raise Exit
d2677 1
a2677 1
  fun n s ->
d2790 1
a2790 1
  fun sh i j ->
d2814 2
a2815 2
    type _ t
  end) =
d2841 1
a2841 1
   val empty : zero fin -> 'a
d2876 1
a2876 1
  fun x y ->
d2892 1
a2892 1
  fun x y ->
d2905 1
a2905 1
  fun x t ->
d2936 1
a2936 1
  fun r s ->
d2982 1
a2982 1
  fun s t acc ->
d3024 11
a3034 4
  let module M =
    (functor
      (T : sig
         type 'a t
d3036 2
a3037 9
      ->
      struct
        let f (Refl : (a T.t, b T.t) eq) = (x :> b)
      end)
      (struct
        type 'a t = unit
      end)
  in
  M.f Refl
d3046 11
a3056 11
  let bad_proof (type a) = (Refl : (< m : a >, < m : a >) eq :> (< m : a >, < >) eq) in
  let downcast : type a. (a, < >) eq -> < > -> a =
    fun (type a) (Refl : (a, < >) eq) (s : < >) -> (s :> a)
  in
  (downcast
     bad_proof
     (object
       method m = x
     end
       :> < >))
  #m
d3087 1
a3087 1
  {|
d3110 1
a3110 1
  {|
d3135 1
a3135 1
  {|
d3147 2
a3148 2
    type t = int
  end)
d3215 2
a3216 2
   let () = Printf.printf "No @@immediate: %fs\n" (test test_foo)
   let () = Printf.printf "With @@immediate: %fs\n" (test test_bar) *)
d3226 1
a3226 1
  {|
d3239 1
a3239 1
  {|
d3253 1
a3253 1
  {|
d3273 2
a3274 2
    type t = string
  end)
d3277 1
a3277 1
  {|
d3295 1
a3295 1
  {|
d3310 1
a3310 1
*)
d3321 1
a3321 1
       type t = s
d3323 2
a3324 2
       let compare = cmp
     end))
d3331 1
a3331 1
         type t = s
d3333 2
a3334 2
         let compare = cmp
       end))
d3500 6
a3505 6
  match (t : s typ) with
  | Int eq -> string_of_int (TypEq.apply eq x)
  | String eq -> Printf.sprintf "%S" (TypEq.apply eq x)
  | Pair (module P) ->
    let x1, x2 = TypEq.apply P.eq x in
    Printf.sprintf "(%s,%s)" (to_string P.t1 x1) (to_string P.t2 x2)
d3559 1
a3559 1
   : (module MapT with type key = string and type data = string and type map = SSMap.map))
d3573 1
a3573 1
    type t = string
d3575 2
a3576 2
    let compare = compare
  end)
d3579 1
a3579 1
    type t = string
d3581 2
a3582 2
    let compare = compare
  end)
d3783 1
a3783 1
    type t = string
d3785 2
a3786 2
    let compare = compare
  end)
d3789 1
a3789 1
    type t = string
d3791 2
a3792 2
    let compare = compare
  end)
d4030 1
a4030 1
    type t = string
d4032 2
a4033 2
    let compare = compare
  end)
d4036 1
a4036 1
    type t = string
d4038 2
a4039 2
    let compare = compare
  end)
d4334 2
a4335 2
    fun _of_a _of_perms v -> (sexp_of_array _of_a) v
  ;;
d4354 2
a4355 2
      fun _of_perms v -> sexp_of_t_ v
    ;;
d4404 2
a4405 2
val abs : 'o is_an_object -> 'o abs
val unabs : 'o abs -> 'o
d4627 2
a4628 2
   module type S = sig
   open Core_kernel.Std
d4630 4
a4633 4
   module Hashtbl1 : module type of Hashtbl
   module Hashtbl2 : sig
   include (module type of Hashtbl)
   end
d4635 1
a4635 1
   module Coverage : Core_kernel.Std.Hashable
d4637 4
a4640 4
   type types = unit constraint 'a Coverage.Table.t = (Coverage.t, 'a) Hashtbl1.t
   type doesnt_type = unit
   constraint 'a Coverage.Table.t = (Coverage.t, 'a) Hashtbl2.t
   end
d4696 2
a4697 2
    type 'a t
    type 'a u = string
d4699 2
a4700 2
    val f : unit -> _ u t
  end) =
d4751 4
a4754 4
    module type T
  end)
    (A : S.T)
    (B : S.T) =
d4779 2
a4780 2
    module type T = S
  end)
d4807 6
a4812 6
   module type PR6513_orig = sig
   module type S =
   sig
   type t
   type u
   end
d4814 7
a4820 7
   module Make: functor (Html5: Html5_sigs.T
   with type 'a Xml.wrap = 'a and
   type 'a wrap = 'a and
   type 'a list_wrap = 'a list)
   -> S with type t = Html5_types.div Html5.elt and
   type u = < foo: Html5.uri >
   end
d4964 2
a4965 2
    (Bar : S with type a = private [> `A ])
    (Baz : S with type b = private < b : Bar.b ; .. >) =
d4998 4
a5001 4
    type a = private [> `A ]
  end) (Baz : module type of struct
          include Bar
        end) =
d5016 2
a5017 2
    type 'a f
  end) =
d5025 3
a5027 3
   module FixId = Fix (struct type 'a f = 'a end)
   let bad : (int, string) eq = FixId.uniq Eq Eq
   let _ = Printf.printf "Oh dear: %s" (cast bad 42)
d5236 15
a5250 15
   module type S = sig module type T module F(X:T) : T end;;
   module type T0 = sig type t end;;
   module type S1 = S with module type T = T0;;
   module type S2 = S with module type T := T0;;
   module type S3 = S with module type T := sig type t = int end;;
   module H = struct
   include (Hashtbl : module type of Hashtbl with
   type statistics := Hashtbl.statistics
   and module type S := Hashtbl.S
   and module Make := Hashtbl.Make
   and module MakeSeeded := Hashtbl.MakeSeeded
   and module type SeededS := Hashtbl.SeededS
   and module type HashedType := Hashtbl.HashedType
   and module type SeededHashedType := Hashtbl.SeededHashedType)
   end;;
d5472 4
a5475 4
  sig
    module N : sig
      val x : int
    end
d5477 2
a5478 2
    module N' = N
  end)
d5511 4
a5514 4
  sig
    module C : sig
      val chr : int -> char
    end
d5516 2
a5517 2
    module C' = C
  end)
d5545 2
a5546 2
    module C = Char
  end) =
d5606 4
a5609 4
    type t
  end) (M : sig
          type t = Y.t
        end) =
d5615 1
a5615 1
  module N = F (M.Y) (M);;*)
d5674 1
a5674 1
   module rec M2 : S' = M2;; (* should succeed! (but this is bad) *)
d5676 1
a5676 1
   let M2.W eq = W Eq;;
d5678 6
a5683 6
   let s = List.fold_right SInt.add [1;2;3] SInt.empty;;
   module SInt2 = Set.Make(Int2);;
   let conv : type a b. (a,b) eq -> a -> b = fun Eq x -> x;;
   let s' : SInt2.t = conv eq s;;
   SInt2.elements s';;
   SInt2.mem 2 s';; (* invariants are broken *)
d5867 1
a5867 1
   module C : sig module L : module type of List end = A
d5873 2
a5874 2
   let () =
   print_endline (string_of_int D'.M.y)
d5888 1
a5888 1
   module C : sig module L : module type of List end = A
d6013 1
a6013 1
  functor (X : sig end) () (Z : sig end) -> struct end
d6075 3
a6077 3
   class world =
   object
   val entity_container : entity entity_container = new entity_container
d6079 2
a6080 2
   method add_entity (s : entity) =
   entity_container#add_entity (s :> entity)
d6082 1
a6082 1
   end
d6101 3
a6103 3
         object
           method v : string = v
         end)
d6126 2
a6127 2
      method m : int
    end
d6139 2
a6140 2
      val x : 'b
    end
d6207 10
a6216 10
      let cur = self#first in
      let rec loop count a =
        if count >= self#len
        then a
        else (
          let a' = f cur#get count a in
          cur#incr ();
          loop (count + 1) a')
      in
      loop 0 a0
d6507 3
a6509 3
   ocamlc -c pr3918a.mli pr3918b.mli
   rm -f pr3918a.cmi
   ocamlc -c pr3918c.ml
d6557 1
a6557 1
      type t = int
d6559 2
a6560 2
      let compare = compare
    end)
d6702 2
a6703 2
    type t
  end) =
d7048 2
a7049 2
      method map : ('a -> 'b) -> 'b M.c
    end
d7162 1
a7162 1
    SET with type t = X.t tree and type elt = X.t) : SET with type elt = int = struct
d7393 4
a7396 4
   module rec Cyclic
   : sig val x : int end
   = struct let x = Cyclic.x + 1 end
   ;;
d7490 2
a7491 2
   module type ASig = sig type a val a:a val print:a -> unit end
   module type BSig = sig type b val b:b val print:b -> unit end
d7493 2
a7494 2
   module A = struct type a = int let a = 0 let print = print_int end
   module B = struct type b = float let b = 0.0 let print = print_float end
d7496 2
a7497 2
   module MakeA (Empty:sig end) : ASig = A
   module MakeB (Empty:sig end) : BSig = B
d7499 1
a7499 1
   module
d7595 2
a7596 2
    HEAP with module Elem = Element)
    (Element : ORDERED) : HEAP with module Elem = Element = struct
d7831 2
a7832 2
    val f : int -> int
  end) =
d7879 2
a7880 2
    val x : int Lazy.t
  end) =
d7973 2
a7974 2
    val x : (module S)
  end) =
d8634 2
a8635 2
    | A, A, A, A, A, A, A, _, U, U -> 1
    | _, _, _, _, _, _, _, G, _, _ -> 1
d8708 1
a8708 1
  fun x y ->
d8763 1
a8763 1
  fun p1 p2 ->
d9449 2
a9450 2
  <- (print_string "coucou";
      x.contents)
d9569 1
a9569 1
    -> unit
d9669 2
a9670 2
  (* __________________________________________________________________________________ *)
  := bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
d9676 2
a9677 2
    (* this is a multiple-line-spanning
       comment *)
d9684 1
a9684 1
    (* this is a multiple-line-spanning
d9709 1
a9709 1
  (* __________________________________________________________________________________ *)
d9723 1
a9723 1
  (* Here is some verbatim formatted text:
d9758 5
a9762 5
    (* Turned on for compatibility reasons. Historically this is because
       there was no actionable way to change third party annotations. Now
       that we have such a support, this behavior should be reconsidered,
       provided our tooling and error reporting is friendly enough to be
       smoothly used by developers. *)
d9787 1
a9787 1
              (* ....................................... *) "-4"] _ -> .) -> y
d9791 5
a9795 5
   (* .............................................. ........................... .......................... ...................... *)
  foo
  (* ....................... *)
  (* ................................. *)
  (* ...................... *)] _
d9804 1
a9804 1
               | _ -> .)
d9807 5
a9811 5
                (* ....................................... *)
               (* ....................................... *)
               "foooooooooooooooooooooooooooo \
                fooooooooooooooooooooooooooooooooooooo"]
               | _ -> .)
d9814 5
a9818 5
                (* ....................................... *)
               let x = a
               and y = b in
               x + y]
               | _ -> .) ->
d9820 3
a9822 3
       (* ... *)
      (* ... *)
      attr (* ... *)]
